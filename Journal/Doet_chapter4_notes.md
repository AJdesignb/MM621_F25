# My notes on THE DESIGN OF EVERYDAY THINGS by DONALD A. NORMAN

## Chapter 4 : Knowing What to Do: Constraints, Discoverability, and Feedback (PG 125 - 141)

### 1. Knowledge in the WORLD vs. Knowledge in the HEAD

**Knowledge in the Head**
Information that’s **memorized or learned**, things you already know from experience, training, or logic.

> Examples:
> 1. Knowing that red means stop.
> 2. Remembering your phone's unlock code.
> 3. Knowing how to ride a bike _(procedural memory)_

**Adavntages:** Quick once learned, no need for external aids.
**Disavantages:** Requires memory and practice; errors occur if you forget or misremember.

**Knowledge in the WORLD**
Information **built into the environment** or object itself, visible cues that remind or guide users.

> EXAMPLES:
> 1. A “push” label on a door.
> 2. A knob that clearly controls a burner in the same position.
> 3. A light that shows a device is on.

**Advantages:** Reduces memory load; helps new or infrequent users.
**Disadvantages:** Can clutter the design; users may become dependent on visual prompts.

***Good design balances both — enough knowledge in the world to help people act correctly, but not so much clutter that it’s overwhelming.
When designs are intuitive, users rely less on memory and more on natural cues.***

### 2. Four kinds of CONSTRAINTS

Constraints help narrow down possible actions and guide correct behavior. Norman identifies four types:

**1. PHYSICAL CONSTRAINTS:** 
The physical shape or structure limits what actions are possible.

> EXAMPLES:
> A USB plug fits only one way.
> Lego bricks connect only via studs.

**2. SEMANTIC CONSTRAINTS:**
Rely on the meaning or purpose of an object and context.

> EXAMPLE:
> A chair’s shape indicates which side to sit on.

**3. CULTURAL CONSTRAINTS:**
Based on learned conventions and social norms.

> EXAMPLES:
> Red means stop, green means go.
> A clockwise turn tightens.

**4. LOGICAL CONSTRAINTS:**
Derived from reasoning about relationships and possibilities.

> EXAMPLE:
> Four burner knobs must each control one burner, the left knob likely controls the left burner.

***Together, these constraints make designs discoverable, users can figure out what to do even without instructions.***

### 3. Cultural Norms, Conventions, & Standards

**CULTURAL NORMS:**
Cultural norms are shared expectations within a culture about appropriate actions.
> Example:
> Reading direction (left-to-right vs right-to-left) affects how we interpret layouts.

**CONVENTIONS:**
Conventions are agreed-upon design habits that become familiar and expected.
> Example:
> “Play” triangles point right; “stop” squares mean halt.
> Links are underlined.

**STANDARS:**
Standards formalize conventions — they become industry-wide rules.
> EXAMPLE:
> Standardized symbols for power (⏻), USB, Wi-Fi; standard side of the road for driving.

***Designs work best when they respect cultural norms and conventions, because users bring those expectations to every new product.***

### 4. Applying Affordances, Signifiers, and Constraints to Everyday Objects (The Problem with Doors)

**AFFORDANCES:** What actions an object allows (e.g., a handle affords pulling).
**SIGNIFIERS:** Cues or signals that indicate where the action should happen (e.g., a flat plate signifies pushing).
**CONSTRAINTS:** Limit possible actions to guide correct use.

**The Problem with Doors (a.k.a. “Norman Doors”):**
- Many doors look the same for push and pull.
- A handle affords pulling — so when a “push” door has a handle, users pull incorrectly.
- This is a signifier failure: the visible design gives misleading cues.
- Adding a “Push” or “Pull” label compensates for bad design — it’s a bandage, not a fix.

***Good design: uses clear signifiers (like a plate on a push door) and constraints (no handle on push side) so the correct action is obvious without words.***

**The Problem with Switches:**

- Poor mapping and lack of constraints make switches confusing.
> Example: A panel of six identical light switches — you don’t know which controls which light.
- The logical constraint is missing because layout doesn’t match physical space.
- Users must rely on knowledge in the head (memory) instead of visible mapping.
- A good design would spatially arrange switches to match their lights, or use labeling and feedback (lights turning on instantly).

### 5. Activity-Centered Controls

- Instead of organizing controls by object, organize them by activity or goal.
> Example: In a car — instead of separate buttons for AC, fan, and temperature, one “comfort” control adjusts all automatically.
- This reduces complexity by aligning controls with what users want to do, not how the system works.
- Encourages discoverability — users can focus on purpose, not mechanism.

***Design should match human tasks, not force users to think like machines.***

### HERE'S A LINK TO THE SLIDES FOR THE [IN-CLASS GROUP ACTIVITIES](https://www.canva.com/design/DAG2XY17Ddo/K4V6rjKV2eqM-41vNXRw0Q/edit?utm_content=DAG2XY17Ddo&utm_campaign=designshare&utm_medium=link2&utm_source=sharebutton)

And here's a fun [Puzzle](https://puzzel.org/en/crossword/play?p=-Oc42xxP7z4ZEcQEOATI)

### 6. Contraints thet force teh Desired Behavior

**FORCING FUNCTIONS:** A forcing function is an extreme form of physical constraint: an action is required (or a stage completed) before the next can proceed if you fail at one stage, you cannot move on.
Under this umbrella there are three specific mechanisms:

**1. Interlocks:** These force operations to occur in a correct sequence. For example, you cannot proceed to checkout until you’ve filled in shipping & billing info.

**2. Lock-Ins:** These keep an operation active, preventing premature termination. E.g., a dialog box that forces you to save changes before closing a document.

**3. Lock-outs:** These prevent an action, access, or entry until certain conditions are met (or prohibit a certain action once something has happened).

_Why Use them ?_

Because they help guide the user toward the correct behaviour by preventing wrong or incomplete actions. They effectively force the system to move or the user to act in a certain way.

**Caveats / things to watch:** Forcing functions can frustrate users if over-used, or if they feel constrained unnecessarily. Also, users may try to bypass them if they feel too rigid. Good design uses them judiciously.

> Example:
> - An oven whose door will not open until the heating cycle finishes (an interlock).
> - A software dialog that won’t let you exit without saving (lock-in).
> - A security gate that won’t let you exit until you’ve completed a required step (lock-out).

These mechanisms help reduce errors and enforce correct workflows in systems where correctness is crucial.

### 7. Conventions, Constraints, and Affordances ###

**1. CONSTRAINTS:** (broader than forcing functions) restrict the set of possible actions; they make some actions impossible, thereby reducing user error.

There are 4 kinds of constraints:

- Physical Constraints: Tangible barriers (shape, size, alignment) that limit how something can be used.
- Cultural Constraints: Actions limited by social conventions or norms (what one “should” do).
- Semantic Constraints: Based on meaning of the situation or object (the affordance semantics).
- Logical Constraints: Based on logic of a system, sequence or structure of parts.

**2. AFFORDANCES:** are what the object allows you to do (e.g., a handle affords pulling).

**3. SIGNIFIERS:** are cues showing where actions should be taken (e.g., a push plate on a door).

**4. CONVENTIONS:** are well‐established norms or standards in design and use; leveraging them helps users by tapping into familiar behaviour. But changing conventions is hard.

**5. LEGACY PROBLEM:** Changing constraints/conventions is difficult because so many products and systems adopt the old standard; users also have learned the old way.

**6. MAPPING, FEEDBACK, DISCOVERABILITY:** are all tied into how affordances, signifiers, constraints work together so the user knows what to do.

Designers need to consciously choose constraints, affordances, signifiers and mappings to produce intuitive, safe, and error‐resistant design.








